
---
1. 认识 TypeScript
    - ts是js的超集，直接写js也可以
    - vue3 98%代码是用ts写的，vue3的ts支持很好，官方也推荐使用ts
    - ts的优势
        - 类型约束：让js和java一样静态编译，让90%以上的代码问题在编译时就能发现。
        - 代码提示
        - 代码重构
        - 更好的接口提示
        - 更好的错误提示
        - 更好的文档提示
2. 使用 TypeSceipt
    - 在路由配置中使用ts类型约束
        ```ts
        import { createRouter, createWebHistory } from 'vue-router'
        import type { RouteRecordRaw } from 'vue-router'

        const routes:RouteRecordRaw[] = [
            //...
        ]

        const router = createRouter({
        history: createWebHistory(),
        routes
        })

        export default router
        ```
    - 自定义类型约束
        - 在 src/types 目录下创建类型文件
        ```ts
        // src/types/home.ts
        export type HomeTopBarItem = {
            title: string,
            icon: string
        }
        ```
        - 在需要使用的地方引入
            - pinia 里所有响应式数据都要添加类型约束 ref<泛型>
            ```ts
            import { defineStore } from 'pinia'
            import { ref } from 'vue'
            import type { HomeBarItem,  RecentlyViewedItem } from '../types/home.ts' // import type 是ts的语法，只在编译时起作用，不会在运行时引入

            export const useHomeStore = defineStore('home', () => {
                const topBarState = ref<HomeBarItem[]>([
                    //...
                ])

                const navBarState = ref<HomeBarItem[]>([
                    //...
                ])

                const recentlyViewedState = ref<RecentlyViewedItem[]>([
                    //...
                ])

                return {
                    topBarState,
                    navBarState,
                    recentlyViewedState
                }
            })
            ```
    - 在.vue文件中使用ts
        - 在.vue文件中使用ts，需要在script标签中添加lang="ts"属性
            ```vue
            <script lang="ts">
                // ts代码
            </script>
            ```
3. vite 工程化
    - 先编译后运行
        - 开发时使用ts、scss等语言，编译后则是正常的js、css文件，浏览器可以直接运行
    - alias 配置
        - 在ts项目中手动安装`@types/node`，可以使用node的内置模块
        - @ -> src
            - `'@': fileURLToPath(new URL('./src', import.meta.url))`
            - `path.resolve(__dirname, 'src')`
        - vant4 自动按需引入
            - 借助`unplugin-vue-components`插件 `@vant/auto-import-resolver`将vant的加载放到vite的启动运行阶段，项目启动更快，首页不需要再加载vant了
    - vue 声明文件
        - vite 会自动识别.vue文件，但是不会识别.vue文件中的ts代码，需要手动添加声明文件
        - 在src目录下创建shims-vue.d.ts文件
            ```ts
            declare module '*.vue' {
                import { defineComponent } from 'vue'
                const component: ReturnType<typeof defineComponent>
                export default component
            }
            ```
        - 在 `tsconfig.app.json` 中添加 `include` 字段
            ```json
            {
                "include": ["src/shims-vue.d.ts"]
            }
            ```
4. 使用 tailwind css
    - 写CSS很快，只需添加原子类名，专注于DOM结构即可
5. toRefs
    - 当从一个响应式对象直接解构时，解构出来的变量不再是响应式的
    - toRefs 将响应对象方便地拆解为多个独立地响应式引用对象。pinia解构多个响应式共享状态时，toRefs很有用。
6. keep alive
    - router-view 路由切换会销毁组件，返回又会重新渲染。
    - 但首页不应该卸载。keep-alive 可以缓存组件，不会销毁。
    - 可以通过 `include` 和 `exclude` prop 来定制。
        - 这两个 prop 的值都可以是一个以英文逗号分隔的字符串、一个正则表达式，或是包含这两种类型的一个数组：
        - include: 只有名称匹配的组件会被缓存
        - exclude: 任何名称匹配的组件都不会被缓存
7. v-slot
    - router-view 与 v-slot + 动态组件
        - https://router.vuejs.org/zh/guide/advanced/router-view-slot.html
        - 和 keep-alive 配合使用
            ```vue
            <router-view v-slot="{Component}">
                <keep-alive>
                    <component :is="Component" />
                </keep-alive>
            </router-view>
            ```
        - 限定部分组件缓存
            ```vue
            <router-view v-slot="{Component}">
                <keep-alive :include="cachedComponents">
                    <component :is="Component" />
                </keep-alive>
            </router-view>

            <script setup lang="ts">
            import { computed } from 'vue'
            import { useRouter } from 'vue-router'

            const router = useRouter();
            const cachedComponents = computed(() => {
                return router.getRoutes()
                    .filter(route => route.meta.cache)
                    .map(route => route.name); 
            });
            </script>
            ```
        